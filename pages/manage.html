---
permalink: /manage
---

<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
		<link rel="stylesheet" type="text/css" href="{{ site.baseurl }}/res/css/style.css"/>	
 		<link href="https://fonts.googleapis.com/css?family=Halant:400|Raleway:500|Roboto:400,500,700" rel="stylesheet">

	</head>
	<body>
		
	
		<div id="app">

			<div id="manage-menu">

				<img src="{{ site.baseurl }}/res/img/visiblepeeps.png">

				<ul class="menu-menu">

					<li>
						<a href="{{ site.baseurl }}/" style="border-top:1px solid rgb(235,235,235);">
							Home
						</a>
					</li>
					
					<li>
						<a href="{{ site.baseurl }}/submit">
							Submit
						</a>
					</li>
					
					<li>
						<a @click="currentView = 'tweetsToApprove'" class="fake-a">
							Tweets to Approve
						</a>
					</li>
					
					<li>
						<a @click="currentView = 'adminUsers'" class="fake-a">
							Adminstrators
						</a>
					</li>
					
					<li>
						<a @click="currentView = 'blockedUsers'" class="fake-a">
							Blocked Users
						</a>
					</li>
					
					<li>
						<a @click="logInOrOut" class="fake-a">
							Log in / Out
						</a>
					</li>

				</ul>

			</div>
			
			<div id="manage-content">
		
				<div v-if="isLoggedIn && isAdmin">
					<div v-if="currentView === 'tweetsToApprove'">
						<h2>Tweets to Approve</h2>
						
						<ul class="manage-text" v-if="tweetsToApprove.length > 0">
							<li v-for="tweet in tweetsToApprove">
								<button @click="approve(tweet)">Approve</button>
								<button style="margin:0 2em 0 0" @click="deny(tweet)">Deny</button>
								<a target="_blank" :href="tweet.url"><% tweet.url %></a> submitted by <a style="font-weight:500" :href="'https://twitter.com/' + tweet.submitter"><% tweet.submitter %></a>
								
							</li>
						</ul>
						
						<p v-else>
							There are no tweets to approve at this time.
						</p>
					</div>
					
					<div v-if="currentView === 'adminUsers'">
						<h2>Admin Users</h2>
						
						<form @submit.prevent="addAdminUser(userToAdmin)">
							<input type="text" v-model="userToAdmin">
							<input type="submit" value="Add">
						</form>
						
						<ul class="manage-text">
							<li v-for="username in adminUsers">
								<button style="margin:0 2em 0 0" @click="removeAdminUser(username)">Remove</button>
								<a :href="'https://twitter.com/' + username"><% username %></a>
							</li>
						</ul>
					</div>
					
					<div v-if="currentView === 'blockedUsers'">
						<h2>Blocked Users</h2>
						
						<form @submit.prevent="blockUser(userToBlock)">
							<input type="text" v-model="userToBlock">
							<input type="submit" value="Block">
						</form>
						
						<ul class="manage-text">
							<li v-for="username in blockedUsers">
								<button style="margin:0 2em 0 0" @click="unblockUser(username)">Unblock</button>
								<a :href="'https://twitter.com/' + username"><% username %></a>
							</li>
						</ul>
					</div>
				</div>
				
				<div v-else>
					You are not logged in. Please log in to manage stuff.
				</div>
			</div>
			
		</div>
		
		<script src="{{ site.baseurl }}/res/js/firebase.js"></script>
		<script src="{{ site.baseurl }}/res/js/vue.min.js"></script>
		<script>
			window.onload = function(){
				// We listen to a bunch of database references. I'm not sure
				// whether this is optimal or not, but it is what it is. :) 
				// Anyway, I'm making references to them here so that I can 
				// turn them off when the user logs out.
				let ref3, ref4, ref5, ref6;
				
				// Initialize the Firebase app settings.
				firebase.initializeApp({
					apiKey: "AIzaSyDahkALUP2HDnuLqiXOt-ScOPobhqFoW84",
					authDomain: "visiblewomen-net.firebaseapp.com",
					databaseURL: "https://visiblewomen-net.firebaseio.com",
					projectId: "visiblewomen-net",
					storageBucket: "visiblewomen-net.appspot.com",
					messagingSenderId: "532732660193"
				});
				
				// Create the Vue app.
				let app = new Vue({
					// Use the #app element.
					el: "#app",
					
					// These are necessary to avoid compilation problems
					// with Jekyll, which uses "{{" and "}}" delimiters.
					delimiters: ["<%", "%>"],
					
					// We use the isLoggedIn and isAdmin variables to hide 
					// the management page from non-logged-in, non-admin users.
					// We also keep lists of tweetsToApprove, adminUsers, and
					// blockedUsers. Finally, the userToAdmin and userToBlock
					// variables represent the text input field data.
					data: {
						isLoggedIn: false,
						isAdmin: false,
						tweetsToApprove: [],
						userToAdmin: "",
						adminUsers: [],
						userToBlock: "",
						blockedUsers: [],
						currentView: "tweetsToApprove",
					},
					
					methods: {
						logInOrOut: function(){
							let self = this;
							if (self.isLoggedIn) self.logout();
							else self.login();
						},
						
						// This is the typical Firebase / Twitter auth flow.
						login: function(){
							let provider = new firebase.auth.TwitterAuthProvider();
							
							firebase.auth().signInWithPopup(provider).then(function(result){
								let db = firebase.database();
								
								// We make sure that we grab the user's Twitter username.
								// For some stupid reason, this is the only time that
								// this information is available to us.
								let username = result.additionalUserInfo.username;
								
								// We store the username in the database under their 
								// Firebase auth UID.
								let ref = db.ref("/allUsers/" + result.user.uid);
								ref.set({username});
							}).catch(function(error){
								console.error(error);
							});
						},
						
						// This the typical Firebase sign-out method, though
						// this is where we also stop listening to the database
						// references.
						logout: function(){
							firebase.auth().signOut();
							if (ref3) ref3.off();
							if (ref4) ref4.off();
							if (ref5) ref5.off();
						},
						
						// This is where we approve tweets.
						approve: function(tweet){
							let self = this;
							
							// Get a reference to the /approvedTweets location
							// in the database.
							let db = firebase.database();
							let ref = db.ref("/approvedTweets");
							
							// Get its value one time.
							ref.once("value").then(function(snapshot){
								// Get the data.
								let approvedTweets = snapshot.val();
								
								// If there's no data there, then create
								// an empty array.
								if (!approvedTweets) approvedTweets = [];
								
								// Otherwise, return an array of the approved tweets.
								// (We have to do this weird mapping thing because
								// Firebase occasionally turns arrays into objects.)
								else approvedTweets = Object.keys(approvedTweets).map(function(key){
									return approvedTweets[key];
								});
								
								// If the tweet url is not already in the list of
								// approved tweets, then...
								if (approvedTweets.indexOf(tweet.url) < 0){
									// Push it into the list.
									approvedTweets.push(tweet.url);
									
									// Push the list up to the database.
									ref.set(approvedTweets);
								}
								
								// Remove the tweet from the list of tweetsToApprove.
								self.tweetsToApprove.splice(self.tweetsToApprove.indexOf(tweet), 1);
								
								// And then push the tweetsToApprove list up to
								// the database as well.
								db.ref("/tweetsToApprove").set(self.tweetsToApprove);
							});
						},
						
						// This is where we deny a tweet.
						deny: function(tweet){
							let self = this;
							let db = firebase.database();
							
							// Remove the tweet from the list of tweets to approve.
							self.tweetsToApprove.splice(self.tweetsToApprove.indexOf(tweet), 1);
							
							// Push the tweetsToApprove list up to the database.
							db.ref("/tweetsToApprove").set(self.tweetsToApprove);
							
							// Check to see if the user should be blocked.
							let shouldBlockUser = confirm("Would you like to block " + tweet.submitter + ", the user who submitted this tweet?");
							
							// If the user should be blocked, the call the blockUser method.
							if (shouldBlockUser){
								self.blockUser(tweet.submitter);
							}
						},
						
						// This is where we add admin users.
						addAdminUser: function(username){
							let self = this;
							let db = firebase.database();
							
							// Get a reference to the /adminUsers list
							// in the database and set their username's
							// value to true.
							db.ref("/adminUsers/" + username).set(true);
							
							// Reset the userToAdmin variable, which will
							// reset the text input field.
							self.userToAdmin = "";
						},
						
						// This is where we remove an admin user.
						removeAdminUser: function(username){
							// Prompt for confirmation that this is really 
							// what we want to do.
							let shouldRemoveAdminUser = confirm("Are you sure that you want to remove " + username + " as an administrator?");
							
							// If we decide not to remove them, then return.
							if (!shouldRemoveAdminUser) return;
							
							// Otherwise, get a reference to /adminUsers in the 
							// database and set their username's value to null.
							let db = firebase.database();
							db.ref("/adminUsers/" + username).set(null);
						},
						
						// This is where we block a user.
						blockUser: function(username){
							let self = this;
							let db = firebase.database();
							
							// Get a reference to /blockedUsers	in the database
							// and set their username's value to true.
							db.ref("/blockedUsers/" + username).set(true);
							
							// Reset the userToBlock variable, which will reset
							// the text input field.
							self.userToBlock = "";
						},
						
						// This is where we unblock a user.
						unblockUser: function(username){
							// Confirm that we really want to unblock them.
							let shouldUnblockUser = confirm("Are you sure that you want to unblock " + username + "?");
							
							// If we change our minds, then return.
							if (!shouldUnblockUser) return;
							
							// Get a reference to /blockedUsers in the database
							// and set their username's value to null.
							let db = firebase.database();
							db.ref("/blockedUsers/" + username).set(null);
						},
					},
					
					mounted: function(){
						let self = this;
						
						// Listen for users logging in and out, and then...
						firebase.auth().onAuthStateChanged(function(user){
							// Unhide the #app element, which was hidden so as
							// not to show the weird markup.
							document.getElementById("app").style.display = "block";
							
							// Set the isLoggedIn variable.
							self.isLoggedIn = !!user;
							
							// If the references are still listening, then 
							// turn them off.
							if (ref3) ref3.off();
							if (ref4) ref4.off();
							if (ref5) ref5.off();
							if (ref6) ref6.off();
							
							// If the user is logged in, then...
							if (user){
								let db = firebase.database();
								
								// Get a reference to the logged-in user's data
								// in the database.
								ref6 = db.ref("/allUsers/" + user.uid);
								
								// Listen to this reference in case their data changes.
								ref6.on("value", function(snapshot){
									// Get their data.
									let user = snapshot.val();
									
									// If the data doesn't exist, then return.
									if (!user) return;
									
									// Get a reference to the list of /adminUsers.
									ref3 = db.ref("/adminUsers");
									
									// Listen to this reference.
									ref3.on("value", function(snapshot2){
										// Get the data.
										let adminUsers = snapshot2.val();
										
										// If there are no admin users, or if this user's
										// username is not in the list of adminUsers, then
										// redirect the user back to the home page.
										if (!adminUsers || !adminUsers[user.username]){
											window.location.href = "{{ site.baseurl }}/";
										}
										
										// Otherwise, store the list of adminUsers for later,
										// since we'll be adding and removing people from it.
										self.adminUsers = Object.keys(adminUsers);
										
										// Indicate that this user is an administrator.
										self.isAdmin = true;
									});
								});
								
								// Get a reference to /tweetsToApprove.
								ref4 = db.ref("/tweetsToApprove");
								
								// Listen to this reference.
								ref4.on("value", function(snapshot){
									let tweetsToApprove = snapshot.val();
									if (!tweetsToApprove) return;
									self.tweetsToApprove = tweetsToApprove;
								});
								
								// Get a reference to /blockedUsers.
								ref5 = db.ref("/blockedUsers");
								
								// Listen to this reference.
								ref5.on("value", function(snapshot){
									// Get the data.
									let blockedUsers = snapshot.val();
									
									// If there are no blocked users, then
									// set blockedUsers to be an empty array,
									// then return.
									if (!blockedUsers){
										self.blockedUsers = [];
										return;
									}
									
									// Set blockedUsers to the list of usernames,
									// which are the keys to the data object.
									self.blockedUsers = Object.keys(blockedUsers);
								});
							}
						});
					},
				});
			};
		</script>
	</body>
</html>
